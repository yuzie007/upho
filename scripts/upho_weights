#!/usr/bin/env python
import argparse
import sys
from pprint import pprint

import numpy as np
from phonopy import file_IO
from phonopy.interface.calculator import read_crystal_structure
from phonopy.units import VaspToTHz
from phonopy.structure.cells import print_cell
from phonopy.phonon.band_structure import get_band_qpoints, get_band_qpoints_by_seekpath
from phonopy.version import __version__ as phonopy_version

from upho import __version__ as upho_version
from upho.api_unfolding import PhonopyUnfolding
from upho.cui.settings import parse_phonopy_conf
from upho.file_io import read_input


def print_version() -> None:
    """Print UPHO version."""
    print(f"UPHO   : {upho_version}")
    print(f"Phonopy: {phonopy_version}")


def get_default_dict_input():
    """
    star :
        type=str
        choices=("none", "all", "sym")
        help="Treatment for the star of q-points."
    """
    default_dict_input = {
        "structure": "POSCAR",
        "structure_ideal": "POSCAR_ideal",
        "force_constants": "FORCE_CONSTANTS",
        "run_mode": "band",
        "star": "sym",
        "projection": "eigenvectors",
    }
    return default_dict_input


def print_cells(phonon, unitcell_filename):
    print("Crsytal structure is read from '%s'." % unitcell_filename)
    supercell = phonon.get_supercell()
    unitcell = phonon.get_unitcell()
    primitive = phonon.get_primitive()
    p2p_map = primitive.get_primitive_to_primitive_map()
    mapping = np.array(
        [p2p_map[x] for x in primitive.get_supercell_to_primitive_map()], dtype="intc"
    )
    s_indep_atoms = phonon.get_symmetry().get_independent_atoms()
    p_indep_atoms = mapping[s_indep_atoms]
    if unitcell.get_number_of_atoms() == primitive.get_number_of_atoms():
        print("-" * 32 + " unit cell " + "-" * 33)
        print_cell(primitive, stars=p_indep_atoms)
    else:
        u2s_map = supercell.get_unitcell_to_supercell_map()
        print("-" * 30 + " primitive cell " + "-" * 30)
        print_cell(primitive, stars=p_indep_atoms)
        print("-" * 32 + " unit cell " + "-" * 33)  # 32 + 11 + 33 = 76
        u2u_map = supercell.get_unitcell_to_unitcell_map()
        u_indep_atoms = [u2u_map[x] for x in s_indep_atoms]
        print_cell(unitcell, mapping=mapping[u2s_map], stars=u_indep_atoms)
    print("-" * 32 + " super cell " + "-" * 32)
    print_cell(supercell, mapping=mapping, stars=s_indep_atoms)
    print("-" * 76)


def add_arguments(parser: argparse.ArgumentParser) -> None:
    """Add arguments."""
    parser.set_defaults(
        is_graph_plot=False,
        is_graph_save=False,
        is_eigenvectors=False,
        is_nosym=False,
        star="none",
        symprec=1e-5,
    )

    parser.add_argument(
        "-p",
        "--plot",
        dest="is_graph_plot",
        action="store_true",
        help="Plot data",
    )
    parser.add_argument(
        "-s",
        "--save",
        dest="is_graph_save",
        action="store_true",
        help="Save plot data in pdf",
    )
    parser.add_argument(
        "--eigvecs",
        "--eigenvectors",
        dest="is_eigenvectors",
        action="store_true",
        help="Output eigenvectors",
    )
    parser.add_argument(
        "--nosym",
        dest="is_nosym",
        action="store_true",
        help="Symmetry is not imposed.",
    )
    parser.add_argument(
        "--tolerance",
        dest="symprec",
        type=float,
        help="Symmetry tolerance to search",
    )
    parser.add_argument(
        "-i",
        "--input_file",
        type=str,
        help="Input file for unfolding.",
    )
    parser.add_argument(
        "--average_masses",
        action="store_true",
        help="Atomic masses are averaged.",
    )
    parser.add_argument(
        "--average_force_constants",
        action="store_true",
        help="Force constants are averaged according to "
        "the ideal crystallographic symmetry.",
    )
    parser.add_argument(
        "conf_file",
        type=str,
        help="Phonopy conf file",
    )


def main():
    print(" ".join(sys.argv))

    parser = argparse.ArgumentParser()
    add_arguments(parser)
    args = parser.parse_args()

    factor = VaspToTHz  # TEST

    print_version()

    settings = parse_phonopy_conf(args.conf_file)

    dict_input = get_default_dict_input()
    if args.input_file is not None:
        dict_input.update(read_input(args.input_file))

    print("=" * 40)
    print("dict_input:")
    pprint(dict_input)
    print("=" * 40)

    run_mode = dict_input["run_mode"]
    star = dict_input["star"]
    projection = dict_input["projection"]

    print("run_mode:", run_mode)
    print("star:", star)
    print("projection:", projection)

    # Phonon calculation mode: Band, mesh, qpoints, etc

    fc_filename = dict_input["force_constants"]
    print("fc_filename:", fc_filename)
    fc = file_IO.parse_FORCE_CONSTANTS(fc_filename)

    unitcell_filename = dict_input["structure"]
    unitcell = read_crystal_structure(unitcell_filename)[0]

    unitcell_ideal_filename = dict_input["structure_ideal"]
    unitcell_ideal = read_crystal_structure(unitcell_ideal_filename)[0]

    supercell_matrix = settings.get("supercell_matrix", None)
    primitive_matrix = settings.get("primitive_matrix", None)
    print("supercell_matrix:")
    print(supercell_matrix)
    print("primitive_matrix:")
    print(primitive_matrix)

    log_level = 2

    phonon = PhonopyUnfolding(
        unitcell=unitcell,
        unitcell_ideal=unitcell_ideal,
        supercell_matrix=supercell_matrix,
        primitive_matrix_ideal=primitive_matrix,
        factor=factor,
        star=star,
        mode=projection,
        symprec=args.symprec,
        log_level=log_level,
    )

    if args.average_masses:
        phonon.average_masses()
        print("Atomic masses are averaged.")

    # Print cells
    print_cells(phonon, unitcell_filename)

    phonon.set_force_constants(fc)

    if args.average_force_constants:
        phonon.average_force_constants()
        print(
            "Force constants are averaged according to "
            "the ideal crystallographic symmetry."
        )

    if run_mode == "band" or run_mode == "mesh" or run_mode == "band_mesh":
        if run_mode == "band" or run_mode == "band_mesh":
            band_paths = settings["band_paths"]
            if "band_points" not in settings:
                npoints = 51  # default value inherited from phonopy
            else:
                npoints = settings["band_points"]
            if settings["is_band_auto"]:
                primitive = phonon._primitive_ideal
                bands = get_band_qpoints_by_seekpath(primitive, npoints)[0]
            else:
                bands = get_band_qpoints(band_paths, npoints)
            phonon.set_band_structure(bands)

    # if run_mode == 'mesh' or run_mode == 'band_mesh':
    #     settings['is_mesh_symmetry'] = False  # For unfolding.
    #     (mesh,
    #      mesh_shift,
    #      t_symmetry,
    #      q_symmetry,
    #      is_gamma_center) = settings.get_mesh()
    #     print("q_symmetry:", q_symmetry)
    #     phonon.set_mesh(mesh,
    #                     mesh_shift,
    #                     is_time_reversal=t_symmetry,
    #                     is_mesh_symmetry=q_symmetry,
    #                     is_eigenvectors=settings.get_is_eigenvectors(),
    #                     is_gamma_center=settings.get_is_gamma_center())
    #     weights = phonon.get_mesh()[1]
    #     if log_level > 0:
    #         if q_symmetry:
    #             print("Number of irreducible q-points on sampling mesh: "
    #                   "%d/%d" % (weights.shape[0], np.prod(mesh)))
    #         else:
    #             print("Number of q-points on sampling mesh: %d" %
    #                   weights.shape[0])

    #     if settings.get_write_mesh():
    #         if settings.get_is_hdf5():
    #             phonon.write_hdf5_mesh()
    #         else:
    #             phonon.write_yaml_mesh()

    #     # Total DOS
    #     if (args.is_graph_plot or settings.get_is_dos_mode()):
    #         dos_range = settings.get_dos_range()

    #         phonon.set_total_DOS(
    #             sigma=settings.get_sigma(),
    #             freq_min=dos_range['min'],
    #             freq_max=dos_range['max'],
    #             freq_pitch=dos_range['step'],
    #             tetrahedron_method=settings.get_is_tetrahedron_method())

    #         if log_level > 0:
    #             print("Calculating DOS...")

    #         if settings.get_fits_Debye_model():
    #             phonon.set_Debye_frequency()
    #             if log_level > 0:
    #                 debye_freq = phonon.get_Debye_frequency()
    #                 print("Debye frequency: %10.5f" % debye_freq)
    #         phonon.write_total_DOS()

    #         if args.is_graph_plot and run_mode != 'band_mesh':
    #             plot = phonon.plot_total_DOS()
    #             if args.is_graph_save:
    #                 plot.savefig('total_dos.pdf')
    #             else:
    #                 plot.show()

    elif run_mode == "single_point":
        phonon.run_single_point(dict_input["qpoint"], dict_input["distance"])


if __name__ == "__main__":
    main()
